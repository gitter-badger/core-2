{"name":"Core","tagline":"Caffeina PHP Toolkit","body":"# Core\r\nCaffeina PHP SDK\r\n\r\n---\r\n\r\n### Installation\r\n\r\n\r\nAdd package to your **composer.json**:\r\n\r\n```\r\n{\r\n  \"require\": {\r\n    \"caffeina-core/core\": \"*\"\r\n  }\r\n}\r\n```\r\n\r\nRun composer:\r\n\r\n```\r\nphp composer.phar install -o\r\n```\r\n\r\nNow the entire toolchain is already available upon the vendor autoloader inclusion.\r\n\r\n```\r\n<?php\r\n// Load vendors\r\ninclude 'vendors/autoload.php';\r\n\r\nRoute::on('/',function(){\r\n\techo \"Hello from Core!\";\r\n});\r\n\r\n// Dispatch route\r\nRoute::dispatch();\r\n\r\n// Send response to the browser\r\nResponse::send();\r\n```\r\n\r\n\r\n---\r\n\r\n# Documentation\r\n\r\n---\r\n\r\n# Dictionary\r\nThe Dictionary class defines a multi-level key value repository with dot notation keys accessors.\r\n\r\n\r\n### Building a dictionary\r\n---\r\n\r\nDictionary is a behaviour class, it must be extended by another class or the value repository will be shared.\r\n\r\n```\r\nclass Config extends Dictionary {}\r\n```\r\n\r\n### Setting a value\r\n---\r\n\r\nYou can set a value from a key path via the `get` method.\r\n\r\nA valid key path is a arbitrary deep sequence of `.` separated strings.\r\n\r\n**Examples**\r\n\r\n- `test`\r\n- `alpha.beta`\r\n- `pages.section.text_block.3`\r\n\r\n\r\n```\r\nConfig::set('options.use_cache',false);\r\n\r\nConfig::set('users.whitelist',[\r\n    'frank.ciccio',\r\n    'walter.submarine',\r\n    'pepen.spacca',\r\n]);\r\n```\r\n\r\n### Getting a value\r\n---\r\n\r\nYou can get a value from a key path via the `get` method.\r\n\r\n```\r\necho Config::get('users.whitelist.1'); // walter.submarine\r\n```\r\nYou can optionally pass a default value to be returned when the requested key is not found. If a callable is passed the returned value will be used.\r\n\r\n```\r\nprint_r( Config::get('a.test',['b'=>123]) ); // Array( [b] => 123 )\r\necho Config::get('a.test.b'); // 123\r\n```\r\n\r\n### Getting all values\r\n---\r\n\r\nYou can get all key-values as an associative array via the `all` method.\r\n\r\n```\r\n$all_data = Config::all();\r\n```\r\n\r\nResults :\r\n\r\n```\r\nArray (\r\n    [users] => Array (\r\n        [whitelist] => Array(\r\n            [0] => frank.ciccio\r\n            [1] => walter.submarine\r\n            [2] => pepen.spacca\r\n        )\r\n    )\r\n)\r\n```\r\n### Clearing the dictionary\r\n---\r\n\r\nYou can clear all values from a dictionary via the `clear` method.\r\n\r\n```\r\nConfig::clear();\r\n```\r\n\r\n### Merging data\r\n---\r\nThe `merge` method extends the dictionary with values passed via an associative array. The second optional parameter will define the if merge data from right-to-left or backwise (default is false = left-to-right ).\r\n\r\n**Setting initial data**\r\n\r\n```\r\nConfig::clear();\r\nConfig::merge([\r\n    'user' => [\r\n        'name' => 'Simon',\r\n        'role' => 'Villain',\r\n    ],\r\n]);\r\n```\r\n\r\n\r\n```\r\nArray (\r\n    [user] => Array (\r\n            [name] => Simon\r\n            [role] => Villain\r\n        )\r\n)\r\n```\r\n\r\n**Standard merge (left-to-right)**\r\n\r\n```\r\nConfig::merge([\r\n    'user' => [\r\n        'name' => 'Frank',\r\n    ],\r\n    'happy' => true,\r\n]);\r\n```\r\n\r\n\r\n```\r\nArray (\r\n    [user] => Array (\r\n            [name] => Frank\r\n            [role] => Villain\r\n        )\r\n    [happy] => 1\r\n)\r\n```\r\n**Back merge (right-to-left)**\r\n\r\n```\r\nConfig::merge([\r\n    'user' => [\r\n        'name' => 'Frank',\r\n    ],\r\n    'happy' => true,\r\n],true);\r\n```\r\n\r\n\r\n```\r\nArray (\r\n    [user] => Array (\r\n            [name] => Simon\r\n            [role] => Villain\r\n        )\r\n    [happy] => 1\r\n)\r\n```\r\n\r\n# Cache\r\nThe Cache module allow you to handle an object persistence between requests and store heavy-computing persistent data.\r\n\r\n\r\n### Retrieve a value\r\n---\r\n\r\nThe simplest way to retrieve a value from cache is via the `get` method.\r\n\r\n```\r\n$shares = Cache::get('shares');\r\n```\r\n\r\nYou can optionally pass a default value and an expire time. The dafault value can be either a mixed or a callable. If you pass the latter it will invoked and the returned value will be used as the default value.\r\n\r\n```\r\n$help = Cache::get('help',true);\r\n\r\n$shares = Cache::get('shares',function(){\r\n   return calc_user_shares();\r\n});\r\n```\r\n\r\n**Important**: When the default value is used (from a cache miss), the cache value will be setted.\r\n\r\n```\r\n$value_generator = function(){\r\n    return time();\r\n};\r\n\r\necho Cache::get('memento',$value_generator); // (Cache MISS) returned : 1389122001 ($value_generator called)\r\necho Cache::get('memento',$value_generator); // (Cache HIT) returned : 1389122001\r\necho Cache::get('memento',$value_generator); // (Cache HIT) returned : 1389122001\r\n\r\n```\r\n\r\n### Setting a value\r\n---\r\n\r\nYou can set a value for a key with the `set` method.\r\n\r\n```\r\nCache::set('friend_or_foe','friend');\r\n```\r\n\r\nYou can pass an optional `expiration` parameter in seconds.\r\n\r\n```\r\nCache::set('friend_or_foe','friend',15); // Expire in 15 sec\r\n\r\necho Cache::get('friend_or_foe'); // friend\r\nsleep(20);\r\necho Cache::get('friend_or_foe'); // (no value)\r\n\r\n```\r\n\r\n### Delete a cached key\r\n---\r\n\r\nYou can delete a cached key with the `delete` method.\r\n\r\n```\r\nCache::delete('friend_or_foe');\r\n```\r\n\r\n### Flush all cached keys\r\n---\r\n\r\nYou can delete all cached keys with the `flush` method.\r\n\r\n```\r\nCache::flush();\r\n```\r\n\r\n### Check if a key is cached\r\n---\r\n\r\nYou can delete a cached key with the `exists` method.\r\n\r\n```\r\nif ( Cache::exists('user_info') ) { ... }\r\n```\r\n\r\n### Increment/Decrement a value\r\n---\r\n\r\nYou can increment/decrement a cached key value with the `inc` and `dec` methods.\r\n\r\n**Example**\r\n\r\n```\r\nEvent::on('user.login',function(){\r\n    Cache::inc('user.logged');\r\n});\r\n\r\nEvent::on('user.logout',function(){\r\n    Cache::dec('user.logged');\r\n});\r\n\r\n```\r\n\r\nDefault inc/dec value is 1, you can however change it by passing the increment/decrement value as the second parameter of the inc/dec methods.\r\n\r\n```\r\nEvent::on('boss.killed',function(){\r\n    Cache::inc('user.score',1000);\r\n});\r\n```\r\n\r\n### Changing caching strategy/driver\r\n---\r\n\r\nYou can choose the Cache driver via the `using` method. The optional second parameter is dictionary of init paramenters to pass to the selected driver.\r\n\r\nThe default driver is **Memory**, a request-only persistent storage.\r\n\r\n**Example**\r\n\r\n```\r\n// Use File-based caching\r\nCache::using('File',[\r\n    'cache_dir' => __DIR__ . '/cache'\r\n]);\r\n```\r\n\r\n\r\n# Event\r\nThe Event module allow you to bind callbacks to custom events.\r\n\r\n\r\n\r\n\r\n\r\n### Attach an handler\r\n---\r\n\r\nYou can attach an handler to a named event via the `on` method.\r\n\r\n```\r\nEvent::on('myevent',function(){\r\n   echo 'Hello, Friend!';\r\n});\r\n```\r\n\r\nMultiple handlers can be attached to the event, they will be sequentially executed when the event will be triggered.\r\n\r\n```\r\nEvent::on('my.event',function(){\r\n   echo 'First!';\r\n});\r\n\r\nEvent::on('my.event',function(){\r\n   echo 'Second!';\r\n});\r\n```\r\nYou can attach handlers to any event name.\r\n\r\n\r\n### Trigger an event\r\n---\r\n\r\nYou can trigger an event via the `trigger` method.\r\n\r\n```\r\nEvent::trigger('my.event');\r\n```\r\nThe `trigger` method will return an array containing the return values of all the handler attached to the event.\r\n\r\n**Example**\r\n\r\n```\r\nEvent::on('my.event',function(){\r\n   return 'Hello!';\r\n});\r\n\r\nEvent::on('my.event',function(){\r\n   return time();\r\n});\r\n\r\n$results = Event::trigger('my.event');\r\n```\r\n\r\nThe `$results` variable contains :\r\n\r\n```\r\narray(2) {\r\n [0]  =>  string(6) \"Hello!\"\r\n [1]  =>  int(1389115191)\r\n}\r\n```\r\n\r\n`NULL` will be returned if no handlers are attached to the event.\r\n\r\nYou can run a trigger only one time with the `triggerOnce` method.\r\n\r\n### Passing parameters to event handlers\r\n---\r\n\r\nYou can pass a variable number of parameter to event handlers appending them after the event name in the `trigger` method.\r\n\r\n```\r\nEvent::on('eat',function($who,$what,$where){\r\n   echo \"$who ate a $what, in the $where.\";\r\n});\r\n\r\nEvent::trigger('eat','Simon','Burrito','Kitchen');\r\n\r\n// Result : Simon ate a Burrito, in the Kitchen\r\n\r\n```\r\n\r\n\r\n# Filters\r\nThe Filters module allow you to permit user overrides to certain values.\r\n\r\n\r\n\r\n\r\n\r\n### Adding a filter\r\n---\r\n\r\nYou can attach a filter function to a custom named group via the `add` method.\r\n\r\n```\r\nFilter::add('title',function($title){\r\n   return strtoupper($title);\r\n});\r\n\r\n```\r\n\r\nMultiple calls to the same group attach multiple filter functions.\r\n\r\n\r\n### Removing a filter\r\n---\r\n\r\nYou can remove an attached filter function to a custom named group via the `remove` method.\r\n\r\n```\r\n$the_filter = function($title){\r\n   return strtoupper($title);\r\n};\r\n\r\nFilter::add('title',$the_filter);\r\n\r\n...\r\n\r\nFilter::remove('title',$the_filter);\r\n\r\n```\r\n\r\nYou can remove all filters attached to a group by not passing the filter function.\r\n\r\n\r\n```\r\nFilter::remove('title');\r\n\r\n```\r\n\r\n### Applying a filter\r\n---\r\n\r\nYou can apply a filter to a value via the `with` method.\r\n\r\n```\r\nFilter::with('title','This was a triumph')\r\n```\r\n\r\n**Example**\r\n\r\n```\r\nFilter::add('title',function($title){\r\n   return strtoupper($title);\r\n});\r\n\r\nFilter::add('title',function($title){\r\n   return $title . '!';\r\n});\r\n\r\necho Filter::with('title','This was a triumph');\r\n\r\n// THIS WAS A TRIUMPH!\r\n\r\n```\r\n\r\n# Route\r\nThe Route module allow you to bind callbacks to HTTP requests.\r\n\r\n\r\n\r\n### URL mapping\r\n---\r\n\r\nYou can define a route via the `on` method.\r\n\r\n```\r\nRoute::on('/hello',function(){\r\n   echo 'Hello, Friend!';\r\n});\r\n```\r\n\r\nThis is the simplest form to define an `HTTP GET` route responding on URL `/hello`.\r\nYou can map the same route to multiple request methods using the fluent api interface.\r\n\r\n```\r\nRoute::on('/hello')\r\n->via(['get','post'])\r\n->with(function(){\r\n   echo 'Hello, Friend!';\r\n});\r\n```\r\nThe `via` method accepts an array of string for handled HTTP request methods.\r\n\r\nThe `with` method binds a callable function to the route.\r\n\r\nIf you need to map various HTTP methods to different callbacks for a single URL _(like exposing a resource via a REST API)_ the `map` method allows you to pass a `method` => `callback` dictionary.\r\n\r\n```\r\nRoute::map('/entity(/:id)/?',[\r\n    'get' => function($id=null){\r\n        // READ: fetch the $id element or all if $id === null\r\n    },\r\n    'post' => function($id=null){\r\n        // CREATE: build a new element\r\n    },\r\n    'put' => function($id=null){\r\n        // UPDATE: modify $id element's properties\r\n    },\r\n    'delete' => function($id=null){\r\n        // DELETE: delete $id element\r\n    },\r\n])\r\n```\r\n\r\n### URL pattern matching and parameters extraction\r\n---\r\nThe route pattern is essentially a Regular Expression with some slight differencies.\r\n\r\nThe pattern is **ALWAYS** matched against the **end** of the `REQUEST_URI` parameter (stripped of the query string).\r\n\r\n**Rules:**\r\n\r\n- every `(...)` group becomes optional\r\n- you can extract parameters via `:named_parameter`\r\n- the pattern can't contain the `#` character\r\n\r\n**Examples:**\r\n\r\n```\r\nRoute::on('/element(/:id)/?',function($id=null){\r\n    if (null === $id){\r\n        $result = get_all_elements();\r\n    } else {\r\n        $result = get_element_by_id($id);\r\n    }\r\n    print_r($result);\r\n});\r\n```\r\n\r\nIn this example the optional (is in a `(...)` group) `:id` is extracted when present, and the route can be optionally terminated by a `/`.\r\n\r\nThis route handles all of these request:\r\n\r\n- `/element`\r\n- `/element/`\r\n- `/element/123`\r\n- `/element/123/`\r\n- `/element/1919191`\r\n- `/element/462635`\r\n- etc..\r\n\r\nBut, as you can see, this example handles also `/element/fooo`.\r\nIf we want to give format rules to an extracted parameters we can use the `rules` method.\r\n\r\nThe `rules` method accepts a `named_parameter` => `regex` dictionary.\r\n\r\n`rules([ 'parameter_name' => 'parameter_regex_pattern' ])`\r\n\r\nWe can strenghten the former example adding rules to the `id` parameter for accepting only integer values _(defined by the \\d+ regex pattern)_.\r\n\r\n**Example:**\r\n\r\n```\r\nRoute::on('/element(/:id)/?',function($id=null){\r\n    if (null === $id){\r\n        $result = get_all_elements();\r\n    } else {\r\n        $result = get_element_by_id($id);\r\n    }\r\n    print_r($result);\r\n})\r\n->rules([ 'id' => '\\d+' ]);\r\n```\r\n\r\n### Route groups\r\n---\r\nYou can encapsulate routes based on a prefix pattern.\r\nIf the current request doesn't match the group URL pattern, relative routes definition are **not** registered.\r\n\r\nThis feature can be used for response-time optimization and for mounting route trees to a dynamic URL prefix.\r\n\r\n**Examples:**\r\n\r\n*** Admin section ***\r\n\r\n```\r\nRoute::group('/admin',function(){\r\n\r\n    Route::on('/',function(){\r\n        echo \"Admin Index\";\r\n    });\r\n\r\n    Route::on('/login')\r\n    ->via(['get','post'])\r\n    ->with(function(){\r\n        // Handle login\r\n    });\r\n\r\n    Route::on('/logout',function(){\r\n       // handle logout\r\n    });\r\n    \r\n});\r\n```\r\n\r\n*** CRUD controller ***\r\n\r\n```\r\nfunction generate_CRUD_controller_for($element_name){\r\n    Route::group('/'.$element_name,function() use ($element_name) {\r\n        Route::map('(/:id)',[\r\n            'get' => function($id=null){\r\n                // READ: fetch the $id element or all if $id === null\r\n            },\r\n            'post' => function($id=null){\r\n                // CREATE: build a new element\r\n            },\r\n            'put' => function($id=null){\r\n                // UPDATE: modify $id element's properties\r\n            },\r\n            'delete' => function($id=null){\r\n                // DELETE: delete $id element\r\n            },\r\n        ])  \r\n    });\r\n}\r\n\r\n// Expose CRUD API for user, job and skill resources\r\ngenerate_CRUD_controller_for('user');\r\ngenerate_CRUD_controller_for('job');\r\ngenerate_CRUD_controller_for('skill');\r\n\r\n\r\n```\r\n\r\n# Shell\r\nThe Shell class can be used to execute OS commands.\r\n\r\n\r\n\r\n\r\n\r\n### Executing a command\r\n---\r\n\r\nThe Shell class permits the invocation of shell commands via dynamic static methods.\r\n\r\n**Examples :**\r\n\r\nRun the `cal` command :\r\n\r\n```\r\necho Shell::cal();\r\n```\r\n\r\nThis outputs :\r\n\r\n```\r\n    Agosto 2014\r\nDo Lu Ma Me Gi Ve Sa\r\n                1  2\r\n 3  4  5  6  7  8  9\r\n10 11 12 13 14 15 16\r\n17 18 19 20 21 22 23\r\n24 25 26 27 28 29 30\r\n31\r\n```\r\n\r\n#### Passing a string\r\n\r\nYou can send multiple arguments to the command by passing parameters to the method.\r\n\r\n```\r\necho Shell::ls('-la ./');\r\n\r\n// or\r\n\r\necho Shell::ls('-la', './');\r\n```\r\n\r\n#### Passing an array\r\n\r\nIf an array is passed as an argument it will be interpreted as an options map :\r\n\r\n```\r\necho Shell::example_command([\r\n    'silent',\r\n    'username' => 'Gordon Freeman',\r\n    'debug' => false,\r\n    'profile' => true,\r\n],'other commands');\r\n```\r\n\r\nCompiles to : `/usr/bin/env example_command --silent --username='Gordon Freeman' --profile other commands`\r\n\r\n#### Passing a Shell object\r\n\r\nIf a Shell object is passed as an argument it will be compiled ad a direct evaluation subcommand :\r\n\r\n```\r\nShell::pipe(\r\n    Shell::cal(),\r\n    Shell::grep(Shell::date('+%d'))\r\n);\r\n```\r\n\r\nCompiles to : `cal | /usr/bin/env grep $(/usr/bin/env date +%d)`\r\n\r\n\r\n#### Lazy Execution\r\n\r\nShell command are not invoked immediately, but only on result evaluation (lazy invocation). You can store the prepared command in a variable for multiple use.\r\n\r\nTo invoke the command you must force the evaluation to string or call the `run` method;\r\n\r\n```\r\n// Not executed.\r\n$command = Shell::cal();\r\n\r\n// Not executed.\r\n$command;\r\n\r\n// Not executed.\r\n!$command;\r\n\r\n// Executed.\r\n$command->run();\r\n\r\n// Executed.\r\n(string)$command;\r\n\r\n// Executed.\r\n$x = $command . '';\r\n```\r\n\r\n### Get the compiled shell command\r\n---\r\n\r\nYou can retrieve the compiled shell command via the `getShellCommand` method.\r\n\r\n```\r\necho Shell::sed('-e','\"s/^ *//\"','-e','\"s/ *$//\"')->getShellCommand();\r\n```\r\n\r\nReturns:\r\n\r\n```\r\n/usr/bin/env sed -e \"s/^ *//\" -e \"s/ *$//\"\r\n```\r\n\r\n### Command piping\r\n---\r\n\r\nIf you want to concatenate multiple commands in a pipeline you must use the `pipe` method.\r\n\r\n```\r\necho Shell::pipe(\r\n  Shell::cal(),\r\n  Shell::grep('-E','\"\\d{4}\"'),\r\n  Shell::sed('-e','\"s/^ *//\"','-e','\"s/ *$//\"')\r\n);\r\n```\r\n\r\nThe compiled command is :\r\n\r\n```\r\ncal | /usr/bin/env grep -E \"\\d{4}\" | /usr/bin/env sed -e \"s/^ *//\" -e \"s/ *$//\"\r\n```\r\n\r\nThe output :\r\n\r\n```\r\nAugust 2014\r\n```\r\n\r\n### Command sequencing\r\n---\r\n\r\nSimilar to command piping you can concatenate multiple shell commands via logical implication ( && ) using the `sequence` method.\r\n\r\n```\r\necho Shell::sequence(\r\n  Shell::nginx('-t'),\r\n  Shell::nginx('-s reload')\r\n);\r\n```\r\n\r\nThe compiled command is :\r\n\r\n```\r\n/usr/bin/env nginx -t && /usr/bin/env nginx -s reload\r\n```\r\n\r\n### Command aliases\r\n---\r\n\r\nYou can create an alias to a complex or dynamic shell command via the `alias` method.\r\n\r\n```\r\nShell::alias('trim',function(){\r\n    return Shell::sed('-e','\"s/^ *//\"','-e','\"s/ *$//\"');\r\n});\r\n```\r\n\r\nNow you can use the alias `trim` as if it was a real command, when invoked the the callback will be called and the resulting Shell object (or raw command if you return a string) will be used in place of the alias.\r\n\r\n**Example:**\r\n\r\n```\r\necho Shell::pipe(\r\n  Shell::cal(),\r\n  Shell::grep('-E','\"\\d{4}\"'),\r\n  Shell::trim()\r\n);\r\n```\r\n\r\nCompiles as : `cal | /usr/bin/env grep -E \"\\d{4}\" | /usr/bin/env sed -e \"s/^ *//\" -e \"s/ *$//\"`\r\n\r\nAnother example are some git aliases for an easy deploy system:\r\n\r\n```\r\nShell::alias('gitCommit',function($commit_message = 'Save'){\r\n    return Shell::sequence(\r\n        Shell::git('add -A'),\r\n        Shell::git('commit -am',Shell::escape($commit_message))\r\n    );\r\n});\r\n\r\nShell::alias('gitCommitAndPush',function($commit_message = 'Save'){\r\n    return Shell::sequence(\r\n        Shell::gitCommit($commit_message),\r\n        Shell::git('pull'),\r\n        Shell::git('push')\r\n    );\r\n});\r\n```\r\n\r\nNow you can \"save\" your work with : `Shell::gitCommit()` or with a commit message `Shell::gitCommit(\"Latest fixes.\")`;\r\n\r\n\r\n# SQL\r\nThe SQL module expose a shorthand for common database methods extending the PDO layer.\r\n\r\n\r\n\r\n\r\n### Bind to database\r\n---\r\n\r\nYou can bind the SQL module to a database with a DSN (Data Source Name) string via the `connect` method.\r\nConnection is lazy-loaded at the first database access.\r\n\r\n```\r\nSQL::connect('mysql:host=localhost;dbname=test','root','password');\r\n```\r\n\r\n### Execute a SQL statement\r\n---\r\n\r\nYou can execute a SQL statement with the `exec` method. The query will be prepared and you can pass optional binding parameters as last function argument.\r\n\r\n```\r\nSQL::exec('TRUNCATE TABLE `users`');\r\n\r\nSQL::exec('DELETE FROM `users` WHERE `age` < 16');\r\n```\r\n\r\n### Retrieve a single value\r\n---\r\n\r\nThe `value` method executes the query, with the optional parameters and returns the first column of the first row of the results.\r\n\r\n```\r\n$total_users = SQL::value('SELECT COUNT(1) FROM `users`');\r\n\r\n$user_is_registered = !!SQL::value('SELECT 1 FROM `users` WHERE username = :usr_name',[\r\n  'usr_name' => $username\r\n]);\r\n```\r\n\r\n\r\n### Retrieve rows\r\n---\r\n\r\nThe `each` method executes the query, with the optional parameters and runs the passed callback with the current row object for every row of the results.\r\n\r\n```\r\nSQL::each('SELECT * FROM `users`',function($user){\r\n  echo '<li><a href=\"mailto:', $user->email ,'\">', $user->name ,'</a></li>';\r\n});\r\n```\r\n\r\n### Retrieve all results\r\n---\r\n\r\nThe `all` method is used to retrieve all results in a single call.\r\n\r\n```\r\necho json_encode( SQL::all('SELECT `name` , `email` FROM `users`') );\r\n```\r\n\r\n\r\n### Insert a new row\r\n---\r\n\r\nThe `insert` method is used to insert into a defined table a new row, passed as an associative array.\r\n\r\n```\r\n$inserted_item_id = SQL::insert('users',[\r\n  'name'     => 'Stannis Baratheon',\r\n  'password' => 'im_the_one_true_king',\r\n]);\r\n```\r\n\r\n### Update a single row\r\n---\r\n\r\nThe `update` method is used to change a single row data, passed as an associative array.\r\n\r\n```\r\nSQL::update('users',[\r\n  'id'       => 321,\r\n  'name'     => 'King Stannis Baratheon',\r\n]);\r\n```\r\n\r\nYou can also override the name of the primary key column as the third function parameter, default is `id`\r\n\r\n```\r\nSQL::update('users',[\r\n  'email'    => 'stannis@baratheon.com',\r\n  'name'     => 'King Stannis Baratheon',\r\n],'email');\r\n```\r\n\r\n### Delete a single row\r\n---\r\n\r\nThe `update` method is used to change a single row data, passed as an associative array.\r\n\r\n```\r\nSQL::update('users',[\r\n  'id'       => 321,\r\n  'name'     => 'King Stannis Baratheon',\r\n]);\r\n```\r\n\r\n\r\n","google":"UA-26094283-19","note":"Don't delete this file! It's used internally to help with page regeneration."}